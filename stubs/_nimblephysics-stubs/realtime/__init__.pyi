"""This provides a native realtime MPC and SSID framework to DART, utilizing the trajectory package to solve."""
from __future__ import annotations
import _nimblephysics.realtime
import typing
import _nimblephysics.simulation
import _nimblephysics.trajectory
import numpy
_Shape = typing.Tuple[int, ...]

__all__ = [
    "MPC",
    "MPCLocal",
    "MPCRemote",
    "Ticker"
]


class MPC():
    def getControlForce(self, now: int) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForceNow(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getRemainingPlanBufferMillis(self) -> int: ...
    def recordGroundTruthState(self, time: int, pos: numpy.ndarray[numpy.float64, _Shape[m, 1]], vel: numpy.ndarray[numpy.float64, _Shape[m, 1]], mass: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def recordGroundTruthStateNow(self, pos: numpy.ndarray[numpy.float64, _Shape[m, 1]], vel: numpy.ndarray[numpy.float64, _Shape[m, 1]], mass: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def registerReplaningListener(self, replanListener: typing.Callable[[int, _nimblephysics.trajectory.TrajectoryRollout, int], None]) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    pass
class MPCLocal(MPC):
    def __init__(self, world: _nimblephysics.simulation.World, loss: _nimblephysics.trajectory.LossFn, planningHorizonMillis: int) -> None: ...
    def adjustPerformance(self, lastOptimizationTimeMillis: int) -> None: ...
    def getCurrentSolution(self) -> _nimblephysics.trajectory.Solution: ...
    def getMaxIterations(self) -> int: ...
    def getOptimizer(self) -> _nimblephysics.trajectory.Optimizer: ...
    def getProblem(self) -> _nimblephysics.trajectory.Problem: ...
    def getRemainingPlanBufferMillis(self) -> int: ...
    def optimizePlan(self, now: int) -> None: ...
    def recordGroundTruthState(self, time: int, pos: numpy.ndarray[numpy.float64, _Shape[m, 1]], vel: numpy.ndarray[numpy.float64, _Shape[m, 1]], mass: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def recordGroundTruthStateNow(self, pos: numpy.ndarray[numpy.float64, _Shape[m, 1]], vel: numpy.ndarray[numpy.float64, _Shape[m, 1]], mass: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def registerReplaningListener(self, replanListener: typing.Callable[[int, _nimblephysics.trajectory.TrajectoryRollout, int], None]) -> None: ...
    def serve(self, port: int) -> None: 
        """
        A blocking call - this starts a gRPC server that clients can connect to to get MPC computations done remotely
        """
    def setEnableLineSearch(self, enabled: bool) -> None: ...
    def setEnableOptimizationGuards(self, enabled: bool) -> None: ...
    def setLoss(self, loss: _nimblephysics.trajectory.LossFn) -> None: ...
    def setMaxIterations(self, maxIterations: int) -> None: ...
    def setOptimizer(self, optimizer: _nimblephysics.trajectory.Optimizer) -> None: ...
    def setProblem(self, problem: _nimblephysics.trajectory.Problem) -> None: ...
    def setRecordIterations(self, enabled: bool) -> None: ...
    def setSilent(self, silent: bool) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    pass
class MPCRemote(MPC):
    @typing.overload
    def __init__(self, host: str, port: int, dofs: int, steps: int, millisPerStep: int) -> None: ...
    @typing.overload
    def __init__(self, local: MPCLocal, ignored: int = 0) -> None: ...
    def getControlForce(self, now: int) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getRemainingPlanBufferMillis(self) -> int: ...
    def recordGroundTruthState(self, time: int, pos: numpy.ndarray[numpy.float64, _Shape[m, 1]], vel: numpy.ndarray[numpy.float64, _Shape[m, 1]], mass: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def recordGroundTruthStateNow(self, pos: numpy.ndarray[numpy.float64, _Shape[m, 1]], vel: numpy.ndarray[numpy.float64, _Shape[m, 1]], mass: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def registerReplaningListener(self, replanListener: typing.Callable[[int, _nimblephysics.trajectory.TrajectoryRollout, int], None]) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    pass
class Ticker():
    def __init__(self, secondsPerTick: float) -> None: ...
    def clear(self) -> None: ...
    def registerTickListener(self, listener: typing.Callable[[int], None]) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    pass
