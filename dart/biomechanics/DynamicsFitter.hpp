#ifndef DART_BIOMECH_DYNAMICS_FITTER_HPP_
#define DART_BIOMECH_DYNAMICS_FITTER_HPP_

#include <memory>
#include <tuple>
#include <vector>

#include <coin/IpIpoptApplication.hpp>
#include <coin/IpTNLP.hpp>

#include "dart/biomechanics/ForcePlate.hpp"
#include "dart/biomechanics/MarkerFitter.hpp"
#include "dart/biomechanics/enums.hpp"
#include "dart/dynamics/BodyNode.hpp"
#include "dart/dynamics/Joint.hpp"
#include "dart/dynamics/Skeleton.hpp"
#include "dart/dynamics/SmartPointer.hpp"
#include "dart/math/Geometry.hpp"
#include "dart/math/MathTypes.hpp"
#include "dart/neural/DifferentiableExternalForce.hpp"
#include "dart/neural/WithRespectTo.hpp"

#define HUMAN_DENSITY_KG_M3 985.0

namespace dart {
namespace biomechanics {

/**
 * This class factors out the code to deal with calculating residual forces, and
 * the associated Jacobians of residual force with respect to lots of different
 * inputs.
 */
class ResidualForceHelper
{
public:
  ResidualForceHelper(
      std::shared_ptr<dynamics::Skeleton> skeleton,
      std::vector<int> forceBodies);

  ///////////////////////////////////////////
  // Computes the full inverse dynamics vector for a specific timestep
  Eigen::VectorXs calculateInverseDynamics(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ///////////////////////////////////////////
  // Computes the full inverse dynamics vector for a specific timestep
  Eigen::VectorXs calculateForwardDynamics(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs tau,
      Eigen::VectorXs forcesConcat);

  //////////////////////////////////////////
  // Computes the joint torques generated by the contact forces at this pose.
  Eigen::VectorXs calculateContactForceTaus(
      Eigen::VectorXs q, Eigen::VectorXs forcesConcat);

  ///////////////////////////////////////////
  // Computes the residual for a specific timestep
  Eigen::Vector6s calculateResidual(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ///////////////////////////////////////////
  // Computes the residual norm for a specific timestep
  s_t calculateResidualNorm(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      s_t torquesMultiple,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the Jacobian of the residual with respect to `wrt`
  Eigen::MatrixXs calculateResidualJacobianWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt);

  ///////////////////////////////////////////
  // Computes the Jacobian of the residual with respect to `wrt`
  Eigen::MatrixXs finiteDifferenceResidualJacobianWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt);

  ///////////////////////////////////////////
  // Computes the gradient of the residual norm with respect to `wrt`
  Eigen::VectorXs calculateResidualNormGradientWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt,
      s_t torquesMultiple,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the gradient of the residual norm with respect to `wrt`
  Eigen::VectorXs finiteDifferenceResidualNormGradientWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt,
      s_t torquesMultiple,
      bool useL1);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in wrt to changes in
  // the residual torque
  Eigen::MatrixXs calculateRootAngularResidualJacobianWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in wrt to changes in
  // the residual torque
  Eigen::MatrixXs finiteDifferenceRootAngularResidualJacobianWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix3s calculateRootAngularResidualJacobianWrtLinearPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix3s finiteDifferenceRootAngularResidualJacobianWrtLinearPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix3s calculateRootAngularResidualJacobianWrtLinearVelocity(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix3s finiteDifferenceRootAngularResidualJacobianWrtLinearVelocity(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix3s calculateRootAngularResidualJacobianWrtLinearAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix3s
  finiteDifferenceRootAngularResidualJacobianWrtLinearAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix<s_t, 3, 2> calculateRootAngularResidualJacobianWrtCoPChange(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      Eigen::Vector3s f,
      int footIndex,
      Eigen::Matrix<s_t, 3, 2> basis);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix<s_t, 3, 2>
  finiteDifferenceRootAngularResidualJacobianWrtCoPChange(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      Eigen::Vector3s f,
      int footIndex,
      Eigen::Matrix<s_t, 3, 2> basis);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix6s calculateRootResidualJacobianWrtPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix6s finiteDifferenceRootResidualJacobianWrtPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the residual at the root, then transforms that to the COM and
  // expresses the torque as a spatial vector (even if the root joint uses euler
  // coordinates for rotation). Linear force is left unchanged.
  Eigen::Vector6s calculateCOMSpatialResidual(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the residual at the root, then transforms that to the COM and
  // expresses the torque as a spatial vector (even if the root joint uses euler
  // coordinates for rotation). Linear force is left unchanged.
  Eigen::Vector3s calculateCOMAngularResidual(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the acceleration we would need at the root in order to keep
  // everything else the same, and end up with zero residuals at the root.
  Eigen::Vector6s calculateResidualFreeRootAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the angular acceleration we would need at the root in order
  // to keep everything else the same, and end up with zero residuals at the
  // root.
  Eigen::Vector3s calculateResidualFreeAngularAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the linear acceleration we would need at the root in order
  // to keep everything else the same, and end up with zero residuals at the
  // root.
  Eigen::Vector3s calculateResidualFreeLinearAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change wrt
  Eigen::MatrixXs calculateResidualFreeRootAngularAccelerationJacobianWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change wrt
  Eigen::MatrixXs
  finiteDifferenceResidualFreeRootAngularAccelerationJacobianWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // position.
  Eigen::Matrix3s
  calculateResidualFreeRootAngularAccelerationJacobianWrtLinearPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // position.
  Eigen::Matrix3s
  finiteDifferenceResidualFreeRootAngularAccelerationJacobianWrtLinearPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::Matrix3s
  calculateResidualFreeRootAngularAccelerationJacobianWrtLinearVelocity(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::Matrix3s
  finiteDifferenceResidualFreeRootAngularAccelerationJacobianWrtLinearVelocity(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // acceleration.
  Eigen::Matrix3s
  calculateResidualFreeRootAngularAccelerationJacobianWrtLinearAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // acceleration.
  Eigen::Matrix3s
  finiteDifferenceResidualFreeRootAngularAccelerationJacobianWrtLinearAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix<s_t, 3, 2>
  calculateResidualFreeRootAngularAccelerationJacobianWrtCoPChange(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      Eigen::Vector3s f,
      int footIndex,
      Eigen::Matrix<s_t, 3, 2> basis);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix<s_t, 3, 2>
  finiteDifferenceResidualFreeRootAngularAccelerationJacobianWrtCoPChange(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      Eigen::Vector3s f,
      int footIndex,
      Eigen::Matrix<s_t, 3, 2> basis);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // position.
  Eigen::Matrix6s calculateResidualFreeRootAccelerationJacobianWrtPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // position.
  Eigen::Matrix6s
  finiteDifferenceResidualFreeRootAccelerationJacobianWrtPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::Matrix6s calculateResidualFreeRootAccelerationJacobianWrtVelocity(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::Matrix6s
  finiteDifferenceResidualFreeRootAccelerationJacobianWrtVelocity(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::VectorXs calculateResidualFreeRootAccelerationJacobianWrtInvMass(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::VectorXs
  finiteDifferenceResidualFreeRootAccelerationJacobianWrtInvMass(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::VectorXs calculateScratchJacobianWrtInvMass(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::VectorXs finiteDifferenceScratchJacobianWrtInvMass(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the location that we would need to move the COM to in order
  // to center the angular residuals. Moving the COM to the computed location
  // doesn't remove angular residuals, but ensures that any remaining residuals
  // are parallel to the net external force on the body.
  Eigen::Vector3s calculateComToCenterAngularResiduals(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This returns a matrix A and vector b, such that Ax+b gives you a legal root
  // trajectory. Here x is a 12 dimensional vector, composed of the
  // concatenation of the initial pos offset, and initial velocity offset.
  std::pair<Eigen::MatrixXs, Eigen::VectorXs> getRootTrajectoryLinearSystem(
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF,
      bool includeAllResidualAccs);

  ////////////////////////////////////////////
  // This returns a matrix A and vector b, such that Ax+b gives you a legal root
  // trajectory. Here x is a 12 dimensional vector, composed of the
  // concatenation of the initial pos offset, and initial velocity offset.
  std::pair<Eigen::MatrixXs, Eigen::VectorXs>
  finiteDifferenceRootTrajectoryLinearSystem(
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF,
      bool includeAllResidualAccs);

  ////////////////////////////////////////////
  // This will go through and compute the "residual-free root acceleration" at
  // each timestep, in that timestep's INPUT CONFIGURATION, and then integrate
  // all those accelerations together to create a new trajeoctory.
  //
  // IMPORTANT: This does NOT allow intermediate "new accelerations" to affect
  // subsequent timestep computations. ALL the "new accelerations" are computed
  // FIRST, and ONLY AFTER EVERY ACCELERATION IS ALREADY COMPUTED are they all
  // integrated together to get a new trajectory.
  //
  // THIS DOES NOT GUARANTEE PHYSICAL CONSISTENCY!!! It is here to help test the
  // getRootTrajectoryLinearSystem() method, and that's pretty much it.
  Eigen::VectorXs getRootTrajectoryLinearSystemTestOutput(
      Eigen::Vector6s initialPosOffset,
      Eigen::Vector6s initialVelOffset,
      Eigen::VectorXs residualAccelerations,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF,
      bool includeAllResidualAccs);

  Eigen::MatrixXs getRootTrajectoryLinearSystemPoses(
      Eigen::Vector6s initialPosOffset,
      Eigen::Vector6s initialVelOffset,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF);

  Eigen::MatrixXs getResidualFreePoses(
      Eigen::Vector6s initialPosOffset,
      Eigen::Vector6s initialVelOffset,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF);

  ////////////////////////////////////////////
  // This returns a matrix A and vector b, such that Ax+b gives you a trajectory
  // with zero linear residuals, along with a "hypothetical" angular trajectory.
  //
  // If you pass in `driftCorrectForcePlates`, then you also get a set of
  // CoP deltas over time for each force plate you pass in, concatenated to the
  // end of the output.
  //
  // If you have `useReactionWheels = false`:
  // The angular trajectory is "hypothetical" in that changing the angles of the
  // root at any timestep will break the linear residuals, so this is just the
  // integration of the "residual free angular acceleration" computed at each
  // timestep. Happily, this hypothetical angular trajectory is linear in the
  // initial conditions, so it's possible to solve this whole system in one
  // shot. This won't produce something legal, but it well let you get your
  // angular accelerations quite close to the desired trajectory.
  //
  // If you have `useReactionWheels = true`:
  // The angular trajectory is NOT the trajectory of the root body, but of the
  // reaction wheels for each euler axis attached to the root.
  std::tuple<Eigen::MatrixXs, Eigen::VectorXs, std::vector<Eigen::MatrixXs>>
  getLinearTrajectoryLinearSystem(
      s_t dt,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF,
      bool useReactionWheels,
      std::vector<ForcePlate> driftCorrectForcePlates
      = std::vector<ForcePlate>(),
      std::vector<std::vector<int>> driftCorrectForcePlatesAssignedToContactBody
      = std::vector<std::vector<int>>(),
      int driftCorrectionBlurRadius = 250,
      int driftCorrectionBlurInterval = 250,
      int maxBuckets = 16);

  ////////////////////////////////////////////
  // The parallel version of getLinearTrajectoryLinearSystem()
  std::pair<Eigen::MatrixXs, Eigen::VectorXs>
  getLinearTrajectoryLinearSystemParallel(
      s_t dt,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF,
      bool useReactionWheels,
      int maxBuckets = 16);

  ////////////////////////////////////////////
  // This returns the same thing as getLinearTrajectoryLinearSystem(), in
  // theory.
  std::tuple<Eigen::MatrixXs, Eigen::VectorXs, std::vector<Eigen::MatrixXs>>
  finiteDifferenceLinearTrajectoryLinearSystem(
      s_t dt,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF,
      bool useReactionWheels,
      std::vector<ForcePlate> driftCorrectForcePlates
      = std::vector<ForcePlate>(),
      std::vector<std::vector<int>> driftCorrectForcePlatesAssignedToContactBody
      = std::vector<std::vector<int>>(),
      int driftCorrectionBlurRadius = 250,
      int driftCorrectionBlurInterval = 250,
      int maxBuckets = 16);

  ////////////////////////////////////////////
  // This produces the same output as you would get from using A*x+b from
  // getLinearTrajectoryLinearSystem().
  Eigen::VectorXs getLinearTrajectoryLinearSystemTestOutput(
      s_t dt,
      Eigen::Vector3s linPosOffset,
      Eigen::Vector3s linVelOffset,
      Eigen::VectorXs linResiduals,
      Eigen::Vector3s angPosOffset,
      Eigen::Vector3s angVelOffset,
      Eigen::VectorXs angResiduals,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF,
      bool useReactionWheels,
      Eigen::VectorXs blurCoeffs,
      std::vector<ForcePlate> driftCorrectForcePlates,
      std::vector<std::vector<int>>
          driftCorrectForcePlatesAssignedToContactBody,
      int driftCorrectionBlurRadius = 250,
      int driftCorrectionBlurInterval = 250,
      int maxBuckets = 16);

  ////////////////////////////////////////////
  // This returns a matrix A and vector b, such that Ax+b gives you a trajectory
  // with zero linear residuals. This linear system maps initial COM position,
  // initial COM velocity, inverse mass, and total mass percentages for each
  // body into a residual free linear root trajectory. Note, input is the COM,
  // but output is the root position.
  std::pair<Eigen::MatrixXs, Eigen::VectorXs> getMultiMassLinearSystem(
      s_t dt,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF,
      int maxBuckets = 16);

  ////////////////////////////////////////////
  // This returns the same thing as getMultiMassLinearSystem(), in
  // theory.
  std::pair<Eigen::MatrixXs, Eigen::VectorXs>
  finiteDifferenceMultiMassLinearSystem(
      s_t dt,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF,
      int maxBuckets = 16);

  ////////////////////////////////////////////
  // This produces the same output as you would get from using A*x+b from
  // getMultiMassLinearSystem().
  Eigen::VectorXs getMultiMassLinearSystemTestOutput(
      s_t dt,
      Eigen::Vector3s linPosOffset,
      Eigen::Vector3s linVelOffset,
      Eigen::VectorXs linearizedMasses,
      Eigen::VectorXs linResiduals,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF,
      int maxBuckets = 16);

  int getNumForceBodies();

  int getExpectedForcesDim();

protected:
  std::shared_ptr<dynamics::Skeleton> mSkel;
  std::vector<int> mForceBodies;
  std::vector<neural::DifferentiableExternalForce> mForces;

  std::vector<std::shared_ptr<dynamics::Skeleton>> mThreadSkels;
  std::vector<ResidualForceHelper> mThreadHelpers;
};

/**
 * This class factors out the logistics for mapping spatial accelerations back
 * to ground reaction forces.
 */
class SpatialNewtonHelper
{
public:
  SpatialNewtonHelper(std::shared_ptr<dynamics::Skeleton> skeleton);

  ///////////////////////////////////////////
  // Computes the f=m*a (in linear components only) difference from observed
  // forces, and presents that in 3-axis form (X,Y,Z world coordinates) in
  // Newtons.
  Eigen::Vector3s calculateLinearForceGap(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ///////////////////////////////////////////
  // Computes the f=m*a (in linear components only) difference from observed
  // forces, and presents that in 3-axis form (X,Y,Z world coordinates) in
  // Newtons.
  s_t calculateLinearForceGapNorm(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the gradient of gap norm with respect to `wrt`
  Eigen::VectorXs calculateLinearForceGapNormGradientWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the gradient of gap norm with respect to `wrt`
  Eigen::VectorXs finiteDifferenceLinearForceGapNormGradientWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the norm of the spatial acceleration vector for each body
  s_t calculateAccelerationNorm(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs weightBodies,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the gradient of the norm of the spatial acceleration vector for
  // each body
  Eigen::VectorXs calculateAccelerationNormGradient(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs weightBodies,
      neural::WithRespectTo* wrt,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the gradient of the norm of the spatial acceleration vector for
  // each body
  Eigen::VectorXs finiteDifferenceAccelerationNormGradient(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs weightBodies,
      neural::WithRespectTo* wrt,
      bool useL1);

protected:
  std::shared_ptr<dynamics::Skeleton> mSkel;
};

/**
 * We create a single initialization object, and pass it around to optimization
 * problems to re-use, because it's not super cheap to construct.
 */
struct DynamicsInitialization
{
  ///////////////////////////////////////////
  // Inputs from files
  std::vector<std::vector<ForcePlate>> forcePlateTrials;
  std::vector<std::vector<int>> overrideForcePlateToGRFNodeAssignment;
  std::vector<Eigen::MatrixXs> originalPoses;
  std::vector<std::vector<std::map<std::string, Eigen::Vector3s>>>
      markerObservationTrials;
  std::vector<std::vector<std::map<std::string, Eigen::Vector3s>>>
      accObservationTrials;
  std::vector<std::vector<std::map<std::string, Eigen::Vector3s>>>
      gyroObservationTrials;
  std::vector<s_t> trialTimesteps;
  std::vector<bool> trialsOnTreadmill;

  // This vector has a single boolean per trial, and allows the pipeline to mark
  // whole trials as "excluded" during processing.
  std::vector<bool> includeTrialsInDynamicsFit;

  ///////////////////////////////////////////
  // Assigning GRFs to specific feet
  std::vector<Eigen::MatrixXs> grfTrials;
  std::vector<int> grfBodyIndices;
  std::vector<dynamics::BodyNode*> grfBodyNodes;

  ///////////////////////////////////////////
  // After the pipeline runs, these hold GRF forces that are perfectly
  // consistent with physics equations. These are the same format as `grfTrials`
  std::vector<Eigen::MatrixXs> perfectGrfTrials;
  std::vector<Eigen::MatrixXs> perfectTorques;
  std::vector<Eigen::MatrixXs> perfectGrfAsCopTorqueForces;
  // These are corrected copy of `forcePlateTrials`
  std::vector<std::vector<ForcePlate>> perfectForcePlateTrials;

  ///////////////////////////////////////////
  // Foot ground contact, and rendering
  std::vector<std::vector<dynamics::BodyNode*>> contactBodies;
  std::vector<std::vector<std::vector<s_t>>> grfBodyContactSphereRadius;
  std::vector<std::vector<std::vector<bool>>> grfBodyForceActive;
  std::vector<std::vector<std::vector<bool>>> grfBodySphereInContact;
  std::vector<std::vector<Eigen::Vector3s>> defaultForcePlateCorners;
  std::vector<std::vector<std::vector<bool>>> grfBodyOffForcePlate;
  // This is the critical value, telling us if we think we're receiving support
  // from off a force plate on this frame
  std::vector<std::vector<MissingGRFStatus>> probablyMissingGRF;
  std::vector<std::vector<MissingGRFReason>> missingGRFReason;
  // This is a map of [trial][forcePlate][timestep], where each force plate is
  // assigned to one of the contact bodies.
  std::vector<std::vector<std::vector<int>>> forcePlatesAssignedToContactBody;

  ///////////////////////////////////////////
  // Rendering reaction wheel positions, if needed
  std::vector<Eigen::MatrixXs> reactionWheels;

  ///////////////////////////////////////////
  // Pure dynamics values
  Eigen::VectorXs bodyMasses;
  Eigen::VectorXs groupMasses;
  Eigen::Matrix<s_t, 3, Eigen::Dynamic> bodyCom;
  Eigen::Matrix<s_t, 6, Eigen::Dynamic> bodyInertia;
  Eigen::VectorXs groupInertias;

  ///////////////////////////////////////////
  // Values from the kinematics fitter that are relevant here as well. The key
  // difference is that the per-trial split is explicit here, because it's so
  // important for the dynamics and indexing.
  std::vector<Eigen::MatrixXs> poseTrials;
  Eigen::VectorXs groupScales;
  std::map<std::string, Eigen::Vector3s> markerOffsets;
  std::vector<std::string> trackingMarkers;

  // These are per-trial, because different trials can have different numbers of
  // observed markers and joints
  std::vector<std::vector<dynamics::Joint*>> joints;
  std::vector<std::vector<std::vector<std::string>>> jointsAdjacentMarkers;
  std::vector<Eigen::VectorXs> jointWeights;
  std::vector<Eigen::MatrixXs> jointCenters;
  std::vector<Eigen::VectorXs> axisWeights;
  std::vector<Eigen::MatrixXs> jointAxis;

  ///////////////////////////////////////////
  // Convenience objects
  std::map<std::string, std::pair<dynamics::BodyNode*, Eigen::Vector3s>>
      updatedMarkerMap;

  ///////////////////////////////////////////
  // To allow us to report how things changed since initialization
  Eigen::VectorXs initialGroupMasses;
  Eigen::VectorXs initialGroupCOMs;
  Eigen::VectorXs initialGroupInertias;
  Eigen::VectorXs initialGroupScales;
  std::map<std::string, Eigen::Vector3s> initialMarkerOffsets;

  ///////////////////////////////////////////
  // To support regularization
  std::vector<Eigen::MatrixXs> regularizePosesTo;
  Eigen::VectorXs regularizeGroupMassesTo;
  Eigen::VectorXs regularizeGroupCOMsTo;
  Eigen::VectorXs regularizeGroupInertiasTo;
  Eigen::VectorXs regularizeGroupScalesTo;
  std::map<std::string, Eigen::Vector3s> regularizeMarkerOffsetsTo;
};

class DynamicsFitProblemConfig
{
public:
  DynamicsFitProblemConfig(std::shared_ptr<dynamics::Skeleton> skeleton);
  DynamicsFitProblemConfig& setDefaults(bool l1 = false);
  DynamicsFitProblemConfig& setLogLossDetails(bool value);

  DynamicsFitProblemConfig& setIncludeMasses(bool value);
  DynamicsFitProblemConfig& setIncludeCOMs(bool value);
  DynamicsFitProblemConfig& setIncludeInertias(bool value);
  DynamicsFitProblemConfig& setIncludePoses(bool value);
  DynamicsFitProblemConfig& setIncludeMarkerOffsets(bool value);
  DynamicsFitProblemConfig& setIncludeBodyScales(bool value);

  DynamicsFitProblemConfig& setPoseSubsetStartIndex(int index);
  DynamicsFitProblemConfig& setPoseSubsetLen(int len);

  DynamicsFitProblemConfig& setLinearNewtonWeight(s_t weight);
  DynamicsFitProblemConfig& setResidualWeight(s_t weight);
  DynamicsFitProblemConfig& setMarkerWeight(s_t weight);
  DynamicsFitProblemConfig& setJointWeight(s_t weight);

  DynamicsFitProblemConfig& setConstrainResidualsZero(bool constrain);
  DynamicsFitProblemConfig& setDisableBounds(bool disable);
  DynamicsFitProblemConfig& setBoundMoveDistance(s_t distance);
  DynamicsFitProblemConfig& setLinearNewtonUseL1(bool l1);
  DynamicsFitProblemConfig& setResidualUseL1(bool l1);
  DynamicsFitProblemConfig& setMarkerUseL1(bool l1);

  DynamicsFitProblemConfig& setRegularizeSpatialAcc(s_t value);
  DynamicsFitProblemConfig& setRegularizeSpatialAccBodyWeights(
      Eigen::VectorXs bodyWeights);
  DynamicsFitProblemConfig& setRegularizeSpatialAccUseL1(bool l1);
  DynamicsFitProblemConfig& setRegularizeJointAcc(s_t value);

  DynamicsFitProblemConfig& setResidualTorqueMultiple(s_t value);
  DynamicsFitProblemConfig& setRegularizeMasses(s_t value);
  DynamicsFitProblemConfig& setRegularizeCOMs(s_t value);
  DynamicsFitProblemConfig& setRegularizeInertias(s_t value);
  DynamicsFitProblemConfig& setRegularizeBodyScales(s_t value);
  DynamicsFitProblemConfig& setRegularizePoses(s_t value);
  DynamicsFitProblemConfig& setRegularizeTrackingMarkerOffsets(s_t value);
  DynamicsFitProblemConfig& setRegularizeAnatomicalMarkerOffsets(s_t value);
  DynamicsFitProblemConfig& setRegularizeImpliedDensity(s_t value);

  DynamicsFitProblemConfig& setConstrainLinearResiduals(s_t value);
  DynamicsFitProblemConfig& setConstrainAngularResiduals(s_t value);

  DynamicsFitProblemConfig& setMaxBlockSize(int value);
  DynamicsFitProblemConfig& setMaxNumTrials(int value);
  DynamicsFitProblemConfig& setOnlyOneTrial(int value);
  DynamicsFitProblemConfig& setMaxNumBlocksPerTrial(int value);

  DynamicsFitProblemConfig& setNumThreads(int value);

public:
  friend class DynamicsFitProblem;
  friend class DynamicsFitter;
  s_t mLinearNewtonWeight;
  s_t mResidualWeight;
  s_t mMarkerWeight;
  s_t mJointWeight;

  bool mLogLossDetails;

  bool mConstrainResidualsZero;
  bool mDisableBounds;
  s_t mBoundMoveDistance;

  bool mLinearNewtonUseL1;
  bool mResidualUseL1;
  bool mMarkerUseL1;

  bool mIncludeMasses;
  bool mIncludeCOMs;
  bool mIncludeInertias;
  bool mIncludeBodyScales;
  bool mIncludePoses;
  bool mIncludeMarkerOffsets;

  int mPoseSubsetStartIndex;
  int mPoseSubsetLen;

  s_t mRegularizeAcc;
  Eigen::VectorXs mRegularizeAccBodyWeights;
  bool mRegularizeAccUseL1;
  s_t mRegularizeJointAcc;

  s_t mResidualTorqueMultiple;
  s_t mRegularizeMasses;
  s_t mRegularizeCOMs;
  s_t mRegularizeInertias;
  s_t mRegularizeBodyScales;
  s_t mRegularizePoses;
  s_t mRegularizeTrackingMarkerOffsets;
  s_t mRegularizeAnatomicalMarkerOffsets;
  s_t mRegularizeImpliedDensity;

  s_t mConstrainLinearResiduals;
  s_t mConstrainAngularResiduals;

  int mMaxBlockSize;
  int mMaxNumTrials;
  int mOnlyOneTrial;
  int mMaxNumBlocksPerTrial;

  int mNumThreads;
};

/**
 * This keeps track of a single "shot" in the DynamicsFitProblem. Keeping things
 * this granular means that we can very tightly customize how we sub-sample the
 * problem, so it's worth the extra book-keeping headache.
 */
struct DynamicsFitProblemBlock
{
  // These are configuration parameters about how the block maps onto the
  // original trial
  int trial;
  int start;
  int len;
  bool constrainToNextBlock;

  // These are the state values that get re-inflated when we unflatten(). When
  // initializing the problem, leave these blank.
  s_t dt;
  Eigen::MatrixXs pos;
  Eigen::MatrixXs vel;
  Eigen::MatrixXs acc;
  Eigen::MatrixXs grf;
  friend class DynamicsFitProblem;
};

/*
 * Reminder: IPOPT will want to free this object when it's done with
 * optimization. This is responsible for actually transcribing the problem into
 * a format IPOpt can work with.
 */
class DynamicsFitProblem : public Ipopt::TNLP
{
public:
  DynamicsFitProblem(
      std::shared_ptr<DynamicsInitialization> init,
      std::shared_ptr<dynamics::Skeleton> skeleton,
      std::vector<std::string> trackingMarkers,
      DynamicsFitProblemConfig config);

  static std::vector<struct DynamicsFitProblemBlock> createBlocks(
      std::shared_ptr<DynamicsInitialization> init,
      DynamicsFitProblemConfig config);

  // This returns the dimension of the decision variables (the length of the
  // flatten() vector), which depends on which variables we choose to include in
  // the optimization problem.
  int getProblemSize();

  // This writes the problem state into a flat vector
  Eigen::VectorXs flatten();

  // This writes the upper bounds into a flat vector
  Eigen::VectorXs flattenUpperBound();

  // This writes the upper bounds into a flat vector
  Eigen::VectorXs flattenLowerBound();

  // This reads the problem state out of a flat vector, and into the init object
  void unflatten(Eigen::VectorXs x);

  // This gets the value of the loss function, as a weighted sum of the
  // discrepancy between measured and expected GRF data and other regularization
  // terms.
  s_t computeLoss(Eigen::VectorXs x, bool logExplanation = false);

  // This gets the value of the loss function, as a weighted sum of the
  // discrepancy between measured and expected GRF data and other regularization
  // terms.
  s_t computeLossParallel(Eigen::VectorXs x, bool logExplanation = false);

  // This gets the gradient of the loss function
  Eigen::VectorXs computeGradient(Eigen::VectorXs x);

  // This gets the gradient of the loss function
  Eigen::VectorXs computeGradientParallel(Eigen::VectorXs x);

  // This gets the gradient of the loss function
  Eigen::VectorXs finiteDifferenceGradient(
      Eigen::VectorXs x, bool useRidders = true);

  // This gets the number of constraints that the problem requires
  int getConstraintSize();

  // This gets the value of the constraints vector. These constraints are only
  // active when we're including positions in the decision variables, and they
  // just enforce that finite differencing is valid to relate velocity,
  // acceleration, and position.
  Eigen::VectorXs computeConstraints(Eigen::VectorXs x);

  // Gets a vector of upper bounds for the constraints. To have a constrant be
  // equal to 0, just set both upper and lower bounds to 0.
  Eigen::VectorXs getConstraintUpperBounds();

  // Gets a vector of lower bounds for the constraints. To have a constrant be
  // equal to 0, just set both upper and lower bounds to 0.
  Eigen::VectorXs getConstraintLowerBounds();

  // This gets the sparse version of the constraints jacobian, returning objects
  // with (row,col,value).
  std::vector<std::tuple<int, int, s_t>> computeSparseConstraintsJacobian();

  // This gets the jacobian of the constraints vector with respect to x. This is
  // constraint wrt x, so doesn't take x as an input
  Eigen::MatrixXs computeConstraintsJacobian();

  // This gets the jacobian of the constraints vector with respect to x
  Eigen::MatrixXs finiteDifferenceConstraintsJacobian();

  // This gets the hessian of the loss function
  Eigen::MatrixXs finiteDifferenceHessian(
      Eigen::VectorXs x, bool useRidders = true);

  // Print out the errors in a gradient vector in human readable form
  bool debugErrors(Eigen::VectorXs fd, Eigen::VectorXs analytical, s_t tol);

  //------------------------- Ipopt::TNLP --------------------------------------
  /// \brief Method to return some info about the nlp
  bool get_nlp_info(
      Ipopt::Index& n,
      Ipopt::Index& m,
      Ipopt::Index& nnz_jac_g,
      Ipopt::Index& nnz_h_lag,
      Ipopt::TNLP::IndexStyleEnum& index_style) override;

  /// \brief Method to return the bounds for my problem
  bool get_bounds_info(
      Ipopt::Index n,
      Ipopt::Number* x_l,
      Ipopt::Number* x_u,
      Ipopt::Index m,
      Ipopt::Number* g_l,
      Ipopt::Number* g_u) override;

  /// \brief Method to return the starting point for the algorithm
  bool get_starting_point(
      Ipopt::Index n,
      bool init_x,
      Ipopt::Number* x,
      bool init_z,
      Ipopt::Number* z_L,
      Ipopt::Number* z_U,
      Ipopt::Index m,
      bool init_lambda,
      Ipopt::Number* lambda) override;

  /// \brief Method to return the objective value
  bool eval_f(
      Ipopt::Index _n,
      const Ipopt::Number* _x,
      bool _new_x,
      Ipopt::Number& _obj_value) override;

  /// \brief Method to return the gradient of the objective
  bool eval_grad_f(
      Ipopt::Index _n,
      const Ipopt::Number* _x,
      bool _new_x,
      Ipopt::Number* _grad_f) override;

  /// \brief Method to return the constraint residuals
  bool eval_g(
      Ipopt::Index _n,
      const Ipopt::Number* _x,
      bool _new_x,
      Ipopt::Index _m,
      Ipopt::Number* _g) override;

  /// \brief Method to return:
  ///        1) The structure of the jacobian (if "values" is nullptr)
  ///        2) The values of the jacobian (if "values" is not nullptr)
  bool eval_jac_g(
      Ipopt::Index _n,
      const Ipopt::Number* _x,
      bool _new_x,
      Ipopt::Index _m,
      Ipopt::Index _nele_jac,
      Ipopt::Index* _iRow,
      Ipopt::Index* _jCol,
      Ipopt::Number* _values) override;

  /// \brief Method to return:
  ///        1) The structure of the hessian of the lagrangian (if "values" is
  ///           nullptr)
  ///        2) The values of the hessian of the lagrangian (if "values" is not
  ///           nullptr)
  bool eval_h(
      Ipopt::Index _n,
      const Ipopt::Number* _x,
      bool _new_x,
      Ipopt::Number _obj_factor,
      Ipopt::Index _m,
      const Ipopt::Number* _lambda,
      bool _new_lambda,
      Ipopt::Index _nele_hess,
      Ipopt::Index* _iRow,
      Ipopt::Index* _jCol,
      Ipopt::Number* _values) override;

  /// \brief This method is called when the algorithm is complete so the TNLP
  ///        can store/write the solution
  void finalize_solution(
      Ipopt::SolverReturn _status,
      Ipopt::Index _n,
      const Ipopt::Number* _x,
      const Ipopt::Number* _z_L,
      const Ipopt::Number* _z_U,
      Ipopt::Index _m,
      const Ipopt::Number* _g,
      const Ipopt::Number* _lambda,
      Ipopt::Number _obj_value,
      const Ipopt::IpoptData* _ip_data,
      Ipopt::IpoptCalculatedQuantities* _ip_cq) override;

  bool intermediate_callback(
      Ipopt::AlgorithmMode mode,
      Ipopt::Index iter,
      Ipopt::Number obj_value,
      Ipopt::Number inf_pr,
      Ipopt::Number inf_du,
      Ipopt::Number mu,
      Ipopt::Number d_norm,
      Ipopt::Number regularization_size,
      Ipopt::Number alpha_du,
      Ipopt::Number alpha_pr,
      Ipopt::Index ls_trials,
      const Ipopt::IpoptData* ip_data,
      Ipopt::IpoptCalculatedQuantities* ip_cq) override;

public:
  std::shared_ptr<DynamicsInitialization> mInit;
  std::shared_ptr<dynamics::Skeleton> mSkeleton;
  DynamicsFitProblemConfig mConfig;

  std::vector<struct DynamicsFitProblemBlock> mBlocks;

  std::vector<std::string> mMarkerNames;
  std::vector<bool> mMarkerIsTracking;
  std::vector<std::pair<dynamics::BodyNode*, Eigen::Vector3s>> mMarkers;

  std::shared_ptr<ResidualForceHelper> mResidualHelper;
  std::shared_ptr<SpatialNewtonHelper> mSpatialNewtonHelper;

  std::vector<std::shared_ptr<dynamics::Skeleton>> mThreadSkeletons;
  std::vector<std::vector<std::pair<dynamics::BodyNode*, Eigen::Vector3s>>>
      mThreadMarkers;
  std::vector<std::vector<std::vector<dynamics::Joint*>>> mThreadJoints;
  std::vector<std::shared_ptr<ResidualForceHelper>> mThreadResidualHelpers;
  std::vector<std::shared_ptr<SpatialNewtonHelper>> mThreadSpatialNewtonHelpers;

  int mBestObjectiveValueIteration;
  s_t mBestObjectiveValue;
  Eigen::VectorXs mInitX;
  Eigen::VectorXs mLastX;
  Eigen::VectorXs mBestObjectiveValueState;
};

class DynamicsFitter
{
public:
  DynamicsFitter(
      std::shared_ptr<dynamics::Skeleton> skeleton,
      std::vector<dynamics::BodyNode*> footNodes,
      std::vector<std::string> trackingMarkers);

  // This bundles together the objects we need in order to track a dynamics
  // problem around through multiple steps of optimization
  static std::shared_ptr<DynamicsInitialization> createInitialization(
      std::shared_ptr<dynamics::Skeleton> skel,
      dynamics::MarkerMap markerMap,
      std::vector<std::string> trackingMarkers,
      std::vector<dynamics::BodyNode*> grfNodes,
      std::vector<std::vector<ForcePlate>> forcePlateTrials,
      std::vector<Eigen::MatrixXs> poseTrials,
      std::vector<int> framesPerSecond,
      std::vector<std::vector<std::map<std::string, Eigen::Vector3s>>>
          markerObservationTrials,
      /// This argument takes a list over trials, where each trial is a list of
      /// integers, one-per-force-plate, where each integer is the index of the
      /// corresponding entry in `grfNodes` to assign that force plate to, or -1
      /// to just rely on the automated assignment algorithm. For example, if
      /// `grfNodes` is [left_foot, right_foot], and we have only one trial with
      /// two force plates, and wish to assign the first force plate to the
      /// right_foot, and second to the left_foot, we would pass in [[1, 0]].
      /// For two trials, where the second trial we wish to use automatic
      /// assignment, we could pass [[1,0], [-1,-1]].
      std::vector<std::vector<int>> overrideForcePlateToGRFNodeAssignment
      = std::vector<std::vector<int>>(),
      /// This argument takes a list over trials, where each trial is a list of
      /// booleans, one per timestep, where a true values indicates that we know
      /// (probably due to a manual human review) that there is no GRF data for
      /// this timestep. This is useful if we have a dataset where we know that
      /// GRF data is missing, but we don't want to just rely on the automated
      /// detection algorithm.
      std::vector<std::vector<MissingGRFStatus>> initializedProbablyMissingGRF
      = std::vector<std::vector<MissingGRFStatus>>());

  // This creates an optimization problem from a kinematics initialization
  static std::shared_ptr<DynamicsInitialization> createInitialization(
      std::shared_ptr<dynamics::Skeleton> skel,
      std::vector<MarkerInitialization> kinematicInit,
      std::vector<std::string> trackingMarkers,
      std::vector<dynamics::BodyNode*> grfNodes,
      std::vector<std::vector<ForcePlate>> forcePlateTrials,
      std::vector<int> framesPerSecond,
      std::vector<std::vector<std::map<std::string, Eigen::Vector3s>>>
          markerObservationTrials,
      /// This argument takes a list over trials, where each trial is a list of
      /// integers, one-per-force-plate, where each integer is the index of the
      /// corresponding entry in `grfNodes` to assign that force plate to, or -1
      /// to just rely on the automated assignment algorithm. For example, if
      /// `grfNodes` is [left_foot, right_foot], and we have only one trial with
      /// two force plates, and wish to assign the first force plate to the
      /// right_foot, and second to the left_foot, we would pass in [[1, 0]].
      /// For two trials, where the second trial we wish to use automatic
      /// assignment, we could pass [[1,0], [-1,-1]].
      std::vector<std::vector<int>> overrideForcePlateToGRFNodeAssignment
      = std::vector<std::vector<int>>(),
      /// This argument takes a list over trials, where each trial is a list of
      /// booleans, one per timestep, where a true values indicates that we know
      /// (probably due to a manual human review) that there is no GRF data for
      /// this timestep. This is useful if we have a dataset where we know that
      /// GRF data is missing, but we don't want to just rely on the automated
      /// detection algorithm.
      std::vector<std::vector<MissingGRFStatus>> initializedProbablyMissingGRF
      = std::vector<std::vector<MissingGRFStatus>>());

  // This retargets a dynamics initialization to another skeleton
  static std::shared_ptr<DynamicsInitialization> retargetInitialization(
      std::shared_ptr<dynamics::Skeleton> skel,
      std::shared_ptr<dynamics::Skeleton> simplifiedSkel,
      std::shared_ptr<DynamicsInitialization> init);

  // This computes and returns the positions of the center of mass at each
  // frame
  std::vector<Eigen::Vector3s> comPositions(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // This computes and returns the positions of the center of mass at each
  // frame that would center the remaining angular residuals
  std::vector<Eigen::Vector3s> comPositionsToCenterResiduals(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // This computes and returns the acceleration of the center of mass at each
  // frame
  std::vector<Eigen::Vector3s> comAccelerations(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // This computes and returns a list of the net forces on the center of mass,
  // given the motion and link masses
  std::vector<Eigen::Vector3s> impliedCOMForces(
      std::shared_ptr<DynamicsInitialization> init,
      int trial,
      Eigen::Vector3s gravity = Eigen::Vector3s::Zero());

  // This returns a list of the total GRF force on the body at each timestep
  std::vector<Eigen::Vector3s> measuredGRFForces(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // Guess if each trial is on a treadmill or not.
  void guessTrialsOnTreadmill(std::shared_ptr<DynamicsInitialization> init);

  // 0. Estimate when each foot is in contact with the ground, which we can use
  // to infer when we're missing GRF data on certain timesteps, so we don't let
  // it mess with our optimization.
  void estimateFootGroundContactsWithStillness(
      std::shared_ptr<DynamicsInitialization> init,
      s_t radius = 0.05,
      s_t minTime = 0.5);

  // 0. Estimate when each foot is in contact with the ground, which we can use
  // to infer when we're missing GRF data on certain timesteps, so we don't let
  // it mess with our optimization.
  void estimateFootGroundContactsWithHeightHeuristic(
      std::shared_ptr<DynamicsInitialization> init,
      bool ignoreFootNotOverForcePlate = false);

  // 0. This goes through and marks any "impact" GRF timesteps (defined as
  // `windowLen` steps after the first non-zero step after a flight phase with
  // zero GRF) as missing GRF data. This allows the system to fill in the
  // missing impacts with best guesses. This is useful if the GRF data was
  // filtered, and the original data is no longer accessible (for example, if
  // working with a published dataset where only filtered GRF is available).
  void markMissingImpacts(
      std::shared_ptr<DynamicsInitialization> init,
      int windowLen = 3,
      bool alsoMarkLiftoff = false);

  // 0. This detects and fills in "blips", which are short segments of observed
  // GRF data in the midst of longer windows of missing data.
  void fillInMissingGRFBlips(
      std::shared_ptr<DynamicsInitialization> init, int blipFilterLen = 20);

  // This will mark trials that have too many frames of missing GRF data, and
  // attempt to drop them from subsequent optimization steps that tune model
  // parameters.
  void excludeTrialsWithTooManyMissingGRFs(
      std::shared_ptr<DynamicsInitialization> init, int threshold = 200);

  // 0. Push the initialization away from hard bounds
  void boundPush(
      std::shared_ptr<DynamicsInitialization> init, s_t boundPush = 0.02);

  // 0. Adjust the skeleton's joint bounds to increase the range of motion
  // during fitting
  void addJointBoundSlack(
      std::shared_ptr<dynamics::Skeleton> skel, s_t slack = 0.1);

  // 0. Smooth the accelerations.
  void smoothAccelerations(
      std::shared_ptr<DynamicsInitialization> init,
      s_t smoothingWeight = 1e1,
      s_t regularizationWeight = 1e-3);

  // 0. Estimate which timesteps probably have unmeasured external forces
  // present. By passing a number smaller than 1.0 to scaleThresholds, we can
  // increase the rate at which we throw out potentially bad data.
  void estimateUnmeasuredExternalForces(
      std::shared_ptr<DynamicsInitialization> init,
      s_t scaleThresholds = 1.0,
      std::vector<int> onlyConsiderTrials = std::vector<int>());

  // 0. Estimate which timesteps probably have unmeasured external torques
  // present. By passing a number smaller than 1.0 to scaleThresholds, we can
  // increase the rate at which we throw out potentially bad data.
  int estimateUnmeasuredExternalTorques(
      std::shared_ptr<DynamicsInitialization> init,
      int trial,
      s_t scaleThresholds = 1.0);

  // This is pretty much just here for testing. It goes through and moves the
  // COM at every timestep to the spot it would need to be in order to minimize
  // angular residuals.
  void moveComsToMinimizeAngularResiduals(
      std::shared_ptr<DynamicsInitialization> init);

  // 1. Adjust the total mass of the body, and change the initial positions and
  // velocities of the body to achieve a least-squares closest COM trajectory to
  // the current kinematic fit.
  bool zeroLinearResidualsOnCOMTrajectory(
      std::shared_ptr<DynamicsInitialization> init,
      int maxTrialsToSolveMassOver = 4,
      bool detectExternalForce = true,
      int driftCorrectionBlurRadius = 250,
      int driftCorrectionBlurInterval = 250,
      s_t regularizeUnobservedTimesteps = 0.01);

  // 1. This is an ablation study, where we just try to separately solve for
  // each section of observed GRF, and leave alone the unobserved sections.
  bool zeroLinearResidualsOnCOMTrajectoryAblation(
      std::shared_ptr<DynamicsInitialization> init,
      int maxTrialsToSolveMassOver);

  // 1. Adjust the total mass of the body and the individual link masses for
  // each body, and change the initial positions and velocities of the body to
  // achieve a least-squares closest COM trajectory to the current kinematic
  // fit.
  // The `boundPush` variable makes the optimizer try to keep link masses at
  // least `boundPush` distance away from their bounds. This makes subsequent
  // interior-point optimizations converge more quickly.
  void multimassZeroLinearResidualsOnCOMTrajectory(
      std::shared_ptr<DynamicsInitialization> init,
      int maxTrialsToSolveMassOver = 4,
      s_t boundPush = 0.01);

  // 1. Change the initial positions and velocities of the body to achieve a
  // least-squares closest COM trajectory to the current kinematic fit, taking
  // into account approximate angular positions.
  std::tuple<bool, bool, double> zeroLinearResidualsAndOptimizeAngular(
      std::shared_ptr<DynamicsInitialization> init,
      int trial,
      Eigen::MatrixXs targetPoses,
      s_t previousTotalResidual,
      int iteration,
      bool useReactionWheels = false,
      s_t weightLinear = 1.0,
      s_t weightAngular = 0.5,
      s_t regularizeLinearResiduals = 0.1,
      s_t regularizeAngularResiduals = 0.1,
      s_t regularizeCopDriftCompensation = 0.1,
      int maxBuckets = 100,
      int maxLeastSquaresIters = 200,
      bool commitCopDriftCompensation = false,
      bool detectUnmeasuredTorque = true,
      s_t avgPositionChangeThreshold = 0.08,
      s_t avgAngularChangeThreshold = 0.15);

  // 1. This runs a number of zeroLinearResidualsAndOptimizeAngular() pipelines,
  // each with different number of timesteps offset between the force plates and
  // the marker data, and returns the best match (minimum marker error at 0
  // residuals).
  bool timeSyncTrialGRF(
      std::shared_ptr<DynamicsInitialization> init,
      int trial,
      bool useReactionWheels = false,
      int maxShiftGRF = 4,
      int iterationsPerShift = 20,
      s_t weightLinear = 1.0,
      s_t weightAngular = 1.0,
      s_t regularizeLinearResiduals = 0.5,
      s_t regularizeAngularResiduals = 0.5,
      s_t regularizeCopDriftCompensation = 1.0,
      int maxBuckets = 16);

  // This runs the initial pipeline, which does an approximate mass optimization
  // and time syncs the GRF data, then re-optimizes the mass and trajectory on
  // the time sync'd data, using some sensible values.
  bool timeSyncAndInitializePipeline(
      std::shared_ptr<DynamicsInitialization> init,
      bool useReactionWheels = false,
      bool shiftGRF = false,
      int maxShiftGRF = 4,
      int iterationsPerShift = 20,
      int maxTrialsToSolveMassOver = 4,
      s_t weightLinear = 1.0,
      s_t weightAngular = 0.5,
      s_t regularizeLinearResiduals = 0.1,
      s_t regularizeAngularResiduals = 0.1,
      s_t regularizeCopDriftCompensation = 1.0,
      int maxBuckets = 100,
      bool detectUnmeasuredTorque = true,
      s_t avgPositionChangeThreshold = 0.20,
      s_t avgAngularChangeThreshold = 0.20,
      bool reoptimizeAnatomicalMarkers = false,
      bool reoptimizeTrackingMarkers = true,
      bool tuneLinkMasses = false);

  // 1.1. Attempt to shift the COM trajectory around to try to get the
  // residual-free trajectory. This can fail, when we've got unmeasured external
  // forces, too much smoothing on force plates, or severe model imperfections
  // (basically, if you just can't fit the data), so it returns a boolean false
  // on failure, and resets everything how it left it.
  bool optimizeSpatialResidualsOnCOMTrajectory(
      std::shared_ptr<DynamicsInitialization> init,
      int trial,
      s_t satisfactoryThreshold = 1e-10,
      int numIters = 600,
      s_t missingResidualRegularization = 1000,
      s_t weightAngular = 2.0,
      s_t weightLastFewTimesteps = 5.0,
      s_t offsetRegularization = 0.001,
      bool regularizeResiduals = true);

  // 1.2. Now that we've got zero residuals, after calling
  // optimizeSpatialResidualsOnCOMTrajectory(), we can estimate the
  // miscalibration on the force plates, if there's consistent error on the
  // marker matches.
  void recalibrateForcePlatesOffset(
      std::shared_ptr<DynamicsInitialization> init,
      int trial,
      s_t maxMovement = 0.03);

  // This analytically re-centers each marker to minimize marker errors.
  void optimizeMarkerOffsets(
      std::shared_ptr<DynamicsInitialization> init,
      bool reoptimizeAnatomicalMarkers = false,
      bool reoptimizeTrackingMarkers = true);

  // This utility recomputes the GRF world wrenches, in case we changed the data
  static void recomputeGRFs(
      std::shared_ptr<DynamicsInitialization> init,
      std::shared_ptr<dynamics::Skeleton> skel,
      int trial);

  // This utility recomputes the GRF world wrenches, in case we changed the data
  static void recomputeGRFs(
      std::vector<ForcePlate> forcePlates,
      const Eigen::MatrixXs& poses,
      const std::vector<dynamics::BodyNode*>& grfBodyNodes,
      const std::vector<int>& overrideForcePlateToGRFNodeAssignment,
      std::vector<std::vector<int>>& forcePlatesAssignedToContactBody,
      Eigen::MatrixXs& grfTrials,
      std::shared_ptr<dynamics::Skeleton> skel,
      s_t forcePlateZeroThresholdNewtons = 3.0);

  // 1. Shift the COM trajectory by a 3vec offset to minimize the amount of
  // remaining residual
  void centerAngularResiduals(std::shared_ptr<DynamicsInitialization> init);

  // 1. Do SGD to try to fit the root trajectory to minimize residuals, leaving
  // everything else fixed
  void optimizeRootTrajectory(
      std::shared_ptr<DynamicsInitialization> init,
      DynamicsFitProblemConfig config);

  // 1. Just use forward dynamics to get zero residuals.
  void zeroSpatialResidualsUsingForwardSim(
      std::shared_ptr<DynamicsInitialization> init, int resetEveryNSteps = -1);

  bool verifyLinearForceConsistency(
      std::shared_ptr<DynamicsInitialization> init);

  // 1. Scale the total mass of the body (keeping the ratios of body links
  // constant) to get it as close as possible to GRF gravity forces.
  void scaleLinkMassesFromGravity(std::shared_ptr<DynamicsInitialization> init);

  // 2. Estimate just link masses, while holding the positions, COMs, and
  // inertias constant
  void estimateLinkMassesFromAcceleration(
      std::shared_ptr<DynamicsInitialization> init,
      s_t regularizationWeight = 50.0);

  // 3. Run larger optimization problems to minimize a weighted combination of
  // residuals and marker RMSE, tweaking a controllable set of variables. This
  // includes the velocity and acceleration as explicit decision variables,
  // constrained by linear constraint equations. That means it needs to be
  // solved with IPOPT, using the interior point method.
  //
  // WARNING: DOES NOT PERFORM WELL WITH WARM STARTS! Becaus it uses the
  // interior point method, this doesn't warm start well. See
  // runImplicitVelAccOptimization() instead.
  void runIPOPTOptimization(
      std::shared_ptr<DynamicsInitialization> init,
      DynamicsFitProblemConfig config);

  // 4. This runs the same optimization problem as
  // runExplicitVelAccOptimization(), but holds velocity and acc as implicit
  // functions of the position values, and removes any constraints. That means
  // we can optimize this using simple gradient descent with line search, and
  // can warm start.
  void runUnconstrainedSGDOptimization(
      std::shared_ptr<DynamicsInitialization> init,
      DynamicsFitProblemConfig config);

  // 4. This runs the same optimization problem as
  // runExplicitVelAccOptimization(), but holds velocity and acc as implicit
  // functions of the position values, and removes any constraints. That means
  // we can optimize this using simple gradient descent with line search, and
  // can warm start.
  void runConstrainedSGDOptimization(
      std::shared_ptr<DynamicsInitialization> init,
      DynamicsFitProblemConfig config);

  // 4. This runs an explicit Newton's method update, using finite differencing
  // to get a Hessian
  void runNewtonsMethod(
      std::shared_ptr<DynamicsInitialization> init,
      DynamicsFitProblemConfig config);

  // 4. This runs an explicit Newton's method update, using a constant Jacobian
  // and constant (vore approximate) "Hessian"
  void runConstantNewtonsMethod(
      std::shared_ptr<DynamicsInitialization> init,
      DynamicsFitProblemConfig config);

  // 5. This attempts to perfect the physical consistency of the data
  void computePerfectGRFs(std::shared_ptr<DynamicsInitialization> init);

  // This plays the simulation forward in Nimble, using the existing GRFs and
  // torques, and checks that everything matches what we expect to see
  bool checkPhysicalConsistency(
      std::shared_ptr<DynamicsInitialization> init,
      s_t maxAcceptableErrors = 1e-3,
      int maxTimestepsToTest = 50);

  // This writes a unified CSV with a ton of different columns in it, describing
  // the selected trial
  void writeCSVData(
      std::string path,
      std::shared_ptr<DynamicsInitialization> init,
      int trial,
      bool useAdjustedGRFs = false,
      std::vector<double> timestamps = {});

  //   // This writes a random-seekable binary format to disk
  //   void writeSubjectOnDisk(
  //       std::string path,
  //       std::string openSimFilePath,
  //       std::shared_ptr<DynamicsInitialization> init,
  //       std::string biologicalSex,
  //       s_t massKg,
  //       s_t heightM,
  //       int ageYears,
  //       bool useAdjustedGRFs = false,
  //       std::vector<std::string> trialNames = std::vector<std::string>(),
  //       std::vector<std::string> subjectTags = std::vector<std::string>(),
  //       std::vector<std::vector<std::string>> trialTags
  //       = std::vector<std::vector<std::string>>(),
  //       std::string href = "",
  //       std::string notes = "",
  //       std::vector<std::vector<std::map<std::string, Eigen::VectorXs>>>
  //           emgObservationTrials
  //       = std::vector<std::vector<std::map<std::string,
  //       Eigen::VectorXs>>>());

  // This saves all the attributes on the init to the skeleton
  void applyInitToSkeleton(
      std::shared_ptr<dynamics::Skeleton> skel,
      std::shared_ptr<DynamicsInitialization> init);

  // This computes the inverse dynamics control forces for a trial, and returns
  // it.
  Eigen::MatrixXs computeInverseDynamics(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // Get the average RMSE, in meters, of the markers
  s_t computeAverageMarkerRMSE(std::shared_ptr<DynamicsInitialization> init);

  // Get the average RMSE, in meters, of the markers
  s_t computeAverageTrialMarkerRMSE(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // Get the average RMSE, in radians, of the reaction wheels
  s_t computeAverageReactionWheelRMSE(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // Get the average max marker error on each frame, in meters, of the markers
  s_t computeAverageMarkerMaxError(
      std::shared_ptr<DynamicsInitialization> init);

  // Get the average max marker error on each frame, in meters, of the markers
  s_t computeAverageTrialMarkerMaxError(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // Get the average residual force (in newtons) and torque (in newton-meters)
  std::pair<s_t, s_t> computeAverageResidualForce(
      std::shared_ptr<DynamicsInitialization> init);

  // Get the average residual force (in newtons) and torque (in newton-meters)
  std::pair<s_t, s_t> computeAverageTrialResidualForce(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // Get the average real measured force (in newtons) and torque (in
  // newton-meters)
  std::pair<s_t, s_t> computeAverageRealForce(
      std::shared_ptr<DynamicsInitialization> init);

  // Get the average real measured force (in newtons) and torque (in
  // newton-meters)
  std::pair<s_t, s_t> computeAverageTrialRealForce(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // Get the average change in the center of pressure point (in meters) after
  // "perfecting" the GRF data
  s_t computeAverageCOPChange(std::shared_ptr<DynamicsInitialization> init);

  // Get the average change in the center of pressure point (in meters) after
  // "perfecting" the GRF data
  s_t computeAverageTrialCOPChange(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // Get the average change in the force vector (in Newtons) after "perfecting"
  // the GRF data
  s_t computeAverageForceMagnitudeChange(
      std::shared_ptr<DynamicsInitialization> init);

  // Get the average change in the force vector (in Newtons) after "perfecting"
  // the GRF data
  s_t computeAverageTrialForceMagnitudeChange(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // Get the average change in the force vector (in Newtons) after "perfecting"
  // the GRF data
  s_t computeAverageForceVectorChange(
      std::shared_ptr<DynamicsInitialization> init);

  // Get the average change in the force vector (in Newtons) after "perfecting"
  // the GRF data
  s_t computeAverageTrialForceVectorChange(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // This debugs the current state, along with visualizations of errors where
  // the dynamics do not match the force plate data
  void saveDynamicsToGUI(
      const std::string& path,
      std::shared_ptr<DynamicsInitialization> init,
      int trialIndex,
      int framesPerSecond);

  void setTolerance(double tol);
  void setIterationLimit(int limit);
  void setLBFGSHistoryLength(int len);
  void setCOMHistogramBuckets(int buckets);
  void setCOMHistogramMaxMovement(s_t maxMovement);
  void setCOMHistogramClipBuckets(int clipBuckets);
  void setFillInEndFramesGrfGaps(int fillInFrames);
  void setCheckDerivatives(bool check);
  void setPrintFrequency(int freq);
  void setSilenceOutput(bool silent);
  void setDisableLinesearch(bool disable);

protected:
  std::shared_ptr<dynamics::Skeleton> mSkeleton;
  std::vector<dynamics::BodyNode*> mFootNodes;
  std::vector<std::string> mTrackingMarkers;
  // These are IPOPT settings
  double mTolerance;
  int mIterationLimit;
  int mLBFGSHistoryLength;
  int mCOMHistogramBuckets;
  s_t mCOMHistogramMaxMovement;
  int mCOMHistogramClipBuckets;
  int mFillInEndFramesGrfGaps;
  bool mCheckDerivatives;
  int mPrintFrequency;
  bool mSilenceOutput;
  bool mDisableLinesearch;
};

}; // namespace biomechanics
}; // namespace dart

#endif